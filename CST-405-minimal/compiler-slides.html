<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal C Compiler - Educational Slide Deck</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }

        .slide-container {
            display: none;
            padding: 60px;
            min-height: 100vh;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .slide-container.active {
            display: flex;
            flex-direction: column;
        }

        .slide {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            font-size: 2.5em;
            margin-bottom: 25px;
            color: #ffeb3b;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }

        h3 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #81c784;
        }

        p, li {
            font-size: 1.2em;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: left;
        }

        .center-text {
            text-align: center;
        }

        pre {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
            overflow-x: auto;
            border-left: 4px solid #ffeb3b;
        }

        code {
            font-family: 'Courier New', monospace;
            font-size: 1em;
            color: #e8f5e8;
        }

        .emoji {
            font-size: 1.5em;
            margin-right: 10px;
        }

        .pipeline {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin: 30px 0;
        }

        .pipeline-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 30px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            min-width: 200px;
        }

        .pipeline-arrow {
            font-size: 2em;
            color: #ffeb3b;
        }

        .navigation {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }

        .nav-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 15px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .slide-counter {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 1em;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            align-items: start;
        }

        .highlight {
            background: rgba(255, 235, 59, 0.2);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #ffeb3b;
            margin: 20px 0;
        }

        .symbol-table {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            margin: 15px 0;
        }

        ul {
            text-align: left;
            margin-left: 20px;
        }

        .fade-in {
            animation: fadeIn 0.8s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison > div {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
        }

        .step {
            background: rgba(255, 255, 255, 0.1);
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #81c784;
        }
    </style>
</head>
<body>
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">20</span>
    </div>

    <!-- Slide 1: Title -->
    <div class="slide-container active">
        <div class="slide fade-in">
            <h1><span class="emoji">🎓</span>Minimal C Compiler</h1>
            <h2>Educational Deep Dive</h2>
            <p class="center-text" style="font-size: 1.5em; margin-top: 40px;">
                A fully functional compiler demonstrating all phases of compilation
            </p>
            <div class="highlight">
                <p><strong>Perfect for teaching compiler design concepts with real, working code</strong></p>
            </div>
        </div>
    </div>

    <!-- Slide 2: Purpose -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🎯</span>Purpose & Goals</h2>
            <div class="two-column">
                <div>
                    <h3>What Makes This Special</h3>
                    <ul>
                        <li><strong>Minimal Language</strong>: Just enough features to demonstrate key concepts</li>
                        <li><strong>Clear Phases</strong>: Each compilation phase is visible and documented</li>
                        <li><strong>Real Output</strong>: Generates actual MIPS assembly</li>
                        <li><strong>Educational Focus</strong>: Extensive comments and explanations</li>
                    </ul>
                </div>
                <div>
                    <h3>Language Features</h3>
                    <pre><code>int x;           // Variable declarations
x = 10;          // Assignment statements
x + y            // Addition operator
print(x);        // Print statement</code></pre>
                    <p><em>That's it! No loops, no conditions, no functions - just the bare essentials.</em></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 3: Compilation Pipeline -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🔧</span>Complete Compilation Pipeline</h2>
            <div class="pipeline">
                <div class="pipeline-box">Source Code (.c)</div>
                <div class="pipeline-arrow">↓</div>
                <div class="pipeline-box">LEXICAL ANALYSIS<br><small>scanner.l → Tokens</small></div>
                <div class="pipeline-arrow">↓</div>
                <div class="pipeline-box">SYNTAX ANALYSIS<br><small>parser.y → AST</small></div>
                <div class="pipeline-arrow">↓</div>
                <div class="pipeline-box">SEMANTIC CHECK<br><small>symtab.c → Symbol Table</small></div>
                <div class="pipeline-arrow">↓</div>
                <div class="pipeline-box">INTERMEDIATE CODE<br><small>tac.c → Three-Address Code</small></div>
                <div class="pipeline-arrow">↓</div>
                <div class="pipeline-box">OPTIMIZATION<br><small>Constant folding, propagation</small></div>
                <div class="pipeline-arrow">↓</div>
                <div class="pipeline-box">CODE GENERATION<br><small>codegen.c → MIPS Assembly</small></div>
            </div>
        </div>
    </div>

    <!-- Slide 4: Memory & Stack -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">💾</span>Understanding the Stack</h2>
            <div class="two-column">
                <div>
                    <h3>What is the Stack?</h3>
                    <p>The stack is a <strong>real region of memory</strong> that every program uses for storing local variables.</p>
                    <pre><code>High Memory (0xFFFFFFFF)
    ┌──────────┐
    │  UNUSED  │
    ├──────────┤
    │  STACK   │ ← Variables here!
    │    ↓     │   (grows down)
$sp →├──────────┤ ← Stack Pointer
    │   FREE   │
    │  SPACE   │
    ├──────────┤
    │   HEAP   │ ← malloc memory
    │    ↑     │   (grows up)
    ├──────────┤
    │ GLOBALS  │
    ├──────────┤
    │  CODE    │ ← Your program
    └──────────┘
Low Memory (0x00000000)</code></pre>
                </div>
                <div>
                    <h3>Stack Layout Example</h3>
                    <pre><code>int x; int y; int z;
x = 10; y = 20; z = x + y;</code></pre>
                    <pre><code>Stack Memory:
┌─────────────────┐
│   z (offset 8)  │ → stores 30
├─────────────────┤
│   y (offset 4)  │ → stores 20
├─────────────────┤
│   x (offset 0)  │ → stores 10
└─────────────────┘ ← $sp</code></pre>
                    <h3>MIPS Instructions</h3>
                    <pre><code># Allocate space
addi $sp, $sp, -400

# Store value in x
li $t0, 10
sw $t0, 0($sp)

# Load value from x
lw $t1, 0($sp)</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 5: Lexical Analysis -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">📖</span>Deep Dive: Lexical Analysis</h2>
            <div class="two-column">
                <div>
                    <h3>What is Lexical Analysis?</h3>
                    <p>The first phase of compilation - reads source code character by character and groups them into <strong>tokens</strong>.</p>

                    <h3>Token Example</h3>
                    <pre><code>// Input: int x = 10 + y;
// Tokens produced:
INT       "int"    // Keyword
ID        "x"      // Identifier
ASSIGN    "="      // Operator
NUM       "10"     // Number
PLUS      "+"      // Operator
ID        "y"      // Identifier
SEMICOLON ";"      // Delimiter</code></pre>
                </div>
                <div>
                    <h3>Scanner Implementation (scanner.l)</h3>
                    <pre><code>DIGIT    [0-9]
LETTER   [a-zA-Z]
ID       {LETTER}({LETTER}|{DIGIT})*
NUMBER   {DIGIT}+

%%
"int"       { return INT; }
"print"     { return PRINT; }
{ID}        { yylval.string = strdup(yytext);
              return ID; }
{NUMBER}    { yylval.num = atoi(yytext);
              return NUM; }
"="         { return ASSIGN; }
"+"         { return PLUS; }
";"         { return SEMICOLON; }
[ \t\n]     { /* skip whitespace */ }
.           { printf("Unexpected: %s\n", yytext); }</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 6: Parsing & AST -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🌳</span>Deep Dive: Parsing & AST Construction</h2>
            <div class="two-column">
                <div>
                    <h3>What is Parsing?</h3>
                    <p>Takes tokens from lexer and builds a hierarchical structure (Abstract Syntax Tree) representing program structure.</p>

                    <h3>Grammar Rules (parser.y)</h3>
                    <pre><code>program : stmt_list { root = $1; }

stmt_list : stmt_list stmt { $$ = createStmtList($1, $2); }
          | stmt           { $$ = $1; }

stmt : declaration       { $$ = $1; }
     | assignment        { $$ = $1; }
     | print_stmt        { $$ = $1; }

declaration : INT ID SEMICOLON
              { $$ = createDecl($2); }

assignment : ID ASSIGN expr SEMICOLON
             { $$ = createAssign($1, $3); }</code></pre>
                </div>
                <div>
                    <h3>Parse Tree vs AST</h3>
                    <pre><code>Source: x = 2 + 3

Parse Tree (detailed):    AST (simplified):
    assignment               ASSIGN
   /    |    \              /      \
  ID   '='   expression   VAR:x   BINOP:+
  |           |                   /      \
 "x"      addition             NUM:2    NUM:3
          /   |   \
       term  '+'  term
        |          |
     NUM:2      NUM:3</code></pre>

                    <h3>AST Node Types</h3>
                    <pre><code>typedef enum {
    NODE_DECL,      // Variable declaration
    NODE_ASSIGN,    // Assignment statement
    NODE_PRINT,     // Print statement
    NODE_BINOP,     // Binary operation
    NODE_NUM,       // Number literal
    NODE_VAR,       // Variable reference
    NODE_STMT_LIST  // Statement sequence
} NodeType;</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 7: Symbol Table -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🗃️</span>Symbol Table Implementation</h2>
            <div class="two-column">
                <div>
                    <h3>Core Data Structures</h3>
                    <pre><code>typedef struct {
    char* name;     // Variable name
    int offset;     // Stack offset
} Symbol;

typedef struct {
    Symbol vars[MAX_VARS];  // Array of vars
    int count;              // # declared
    int nextOffset;         // Next stack pos
} SymbolTable;</code></pre>

                    <h3>Key Operations</h3>
                    <ul>
                        <li><code>initSymTab()</code> - Initialize empty table</li>
                        <li><code>addVar(name)</code> - Add variable, return offset</li>
                        <li><code>getVarOffset(name)</code> - Look up offset</li>
                        <li><code>isVarDeclared(name)</code> - Check existence</li>
                    </ul>
                </div>
                <div>
                    <h3>Symbol Table Evolution</h3>

                    <div class="step">
                        <strong>1. Initialization:</strong>
                        <div class="symbol-table">
=== SYMBOL TABLE STATE ===<br>
Count: 0, Next Offset: 0<br>
(empty)<br>
==========================
                        </div>
                    </div>

                    <div class="step">
                        <strong>2. After "int x;":</strong>
                        <div class="symbol-table">
=== SYMBOL TABLE STATE ===<br>
Count: 1, Next Offset: 4<br>
Variables:<br>
  [0] x -> offset 0<br>
==========================
                        </div>
                    </div>

                    <div class="step">
                        <strong>3. After "int y;":</strong>
                        <div class="symbol-table">
=== SYMBOL TABLE STATE ===<br>
Count: 2, Next Offset: 8<br>
Variables:<br>
  [0] x -> offset 0<br>
  [1] y -> offset 4<br>
==========================
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 8: TAC Generation -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🔄</span>Three-Address Code (TAC) Generation</h2>
            <div class="two-column">
                <div>
                    <h3>What is TAC?</h3>
                    <p>Intermediate representation where each instruction has at most <strong>three operands</strong>:</p>
                    <pre><code>result = operand1 operator operand2</code></pre>

                    <h3>TAC Instruction Types</h3>
                    <pre><code>typedef enum {
    TAC_ADD,     // result = arg1 + arg2
    TAC_ASSIGN,  // result = arg1
    TAC_PRINT,   // print(arg1)
    TAC_DECL     // declare result
} TACOp;</code></pre>

                    <h3>AST to TAC Conversion</h3>
                    <ul>
                        <li><strong>Declarations</strong>: NODE_DECL → TAC_DECL</li>
                        <li><strong>Assignments</strong>: NODE_ASSIGN → TAC_ASSIGN</li>
                        <li><strong>Expressions</strong>: NODE_BINOP → TAC_ADD with temps</li>
                        <li><strong>Print statements</strong>: NODE_PRINT → TAC_PRINT</li>
                    </ul>
                </div>
                <div>
                    <h3>TAC Generation Example</h3>
                    <pre><code>// Source Code:
int x; int y;
x = 10; y = 20;
print(x + y);</code></pre>

                    <pre><code>// Generated TAC:
1: DECL x          // Declare variable 'x'
2: DECL y          // Declare variable 'y'
3: x = 10          // Assign constant to x
4: y = 20          // Assign constant to y
5: t0 = x + y      // Add: store result in t0
6: PRINT t0        // Output value of t0</code></pre>

                    <h3>Complex Expression Example</h3>
                    <pre><code>// Source: result = (a + b) * (c + d);

// TAC Generation:
t1 = a + b          // Evaluate first subexp
t2 = c + d          // Evaluate second subexp
t3 = t1 * t2        // Combine results
result = t3         // Final assignment</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 9: TAC Optimization -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">⚡</span>TAC Optimization</h2>
            <div class="two-column">
                <div>
                    <h3>Optimization Techniques</h3>

                    <div class="step">
                        <strong>1. Constant Folding</strong>
                        <p>Evaluates compile-time constant expressions</p>
                        <pre><code>10 + 20  →  30 (directly)</code></pre>
                    </div>

                    <div class="step">
                        <strong>2. Copy Propagation</strong>
                        <p>Replaces variable references with known values</p>
                        <pre><code>x = 5;
y = x + 3;  →  y = 5 + 3;</code></pre>
                    </div>

                    <h3>Value Propagation Table</h3>
                    <pre><code>typedef struct {
    char* var;    // Variable name
    char* value;  // Known value
} VarValue;</code></pre>
                </div>
                <div>
                    <h3>Optimization Example</h3>

                    <div class="comparison">
                        <div>
                            <strong>Original TAC:</strong>
                            <pre><code>1: DECL x
2: DECL y
3: x = 10        // x maps to "10"
4: y = 20        // y maps to "20"
5: t0 = x + y    // Substitute: 10 + 20
6: PRINT t0</code></pre>
                        </div>
                        <div>
                            <strong>Optimized TAC:</strong>
                            <pre><code>1: DECL x
2: DECL y
3: x = 10        // Constant: 10
4: y = 20        // Constant: 20
5: t0 = 30       // Folded: 10 + 20 = 30
6: PRINT 30      // Propagated constant</code></pre>
                        </div>
                    </div>

                    <h3>Optimization Process</h3>
                    <ol>
                        <li><strong>Track assignments</strong>: Store variable-value mappings</li>
                        <li><strong>Substitute references</strong>: Replace variables with known values</li>
                        <li><strong>Fold constants</strong>: Evaluate expressions at compile-time</li>
                        <li><strong>Propagate results</strong>: Update propagation table</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 10: MIPS Code Generation -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🖥️</span>MIPS Code Generation</h2>
            <div class="two-column">
                <div>
                    <h3>MIPS Architecture Used</h3>

                    <strong>Registers:</strong>
                    <ul>
                        <li><code>$sp</code>: Stack pointer</li>
                        <li><code>$t0-$t7</code>: Temporary registers</li>
                        <li><code>$a0</code>: Argument register</li>
                        <li><code>$v0</code>: System call number</li>
                    </ul>

                    <strong>Memory Layout:</strong>
                    <ul>
                        <li>Variables on stack with negative offsets from <code>$sp</code></li>
                        <li>Stack grows downward (decreasing addresses)</li>
                        <li>Each integer = 4 bytes</li>
                    </ul>

                    <h3>Variable Operations</h3>
                    <pre><code># Declaration: adds to symbol table
# Declared x at offset 0

# Assignment: x = 10;
li $t0, 10        # Load immediate
sw $t0, 0($sp)    # Store word

# Variable Access: reading x
lw $t1, 0($sp)    # Load word

# Addition: x + y
lw $t0, 0($sp)    # Load x
lw $t1, 4($sp)    # Load y
add $t0, $t0, $t1 # Add values</code></pre>
                </div>
                <div>
                    <h3>Complete MIPS Example</h3>
                    <pre><code>// Source:
int x; int y;
x = 10; y = 20;
print(x + y);</code></pre>

                    <pre><code># Generated MIPS:
.data
.text
.globl main
main:
    # Allocate stack space
    addi $sp, $sp, -400

    # Declared x at offset 0
    # Declared y at offset 4

    # x = 10;
    li $t0, 10
    sw $t0, 0($sp)

    # y = 20;
    li $t1, 20
    sw $t1, 4($sp)

    # print(x + y);
    lw $t0, 0($sp)        # Load x
    lw $t1, 4($sp)        # Load y
    add $t0, $t0, $t1     # x + y
    move $a0, $t0         # Prepare for print
    li $v0, 1             # Print integer syscall
    syscall
    li $v0, 11            # Print newline
    li $a0, 10
    syscall

    # Exit program
    addi $sp, $sp, 400
    li $v0, 10
    syscall</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 11: Semantic Analysis Deep Dive -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🔬</span>Deep Dive: Semantic Analysis</h2>
            <div class="two-column">
                <div>
                    <h3>What is Semantic Analysis?</h3>
                    <p>Ensures the program makes <strong>sense</strong> - variables are declared before use, types match, etc.</p>

                    <h3>Semantic Checks</h3>
                    <ol>
                        <li><strong>Declaration before use</strong>: Every variable must be declared</li>
                        <li><strong>No redeclaration</strong>: Can't declare same variable twice</li>
                        <li><strong>Type consistency</strong>: All variables are integers</li>
                    </ol>

                    <h3>Symbol Table Lookup</h3>
                    <pre><code>// Our simple O(n) lookup:
int getVarOffset(char* name) {
    for (int i = 0; i < symtab.count; i++) {
        if (strcmp(symtab.vars[i].name, name) == 0) {
            return symtab.vars[i].offset;
        }
    }
    return -1;  // Not found
}

// Production compiler would use:
// hash_table_lookup(symbol_table, name)
// -> O(1) average case</code></pre>
                </div>
                <div>
                    <h3>Advanced: Scope Management</h3>
                    <p>Our compiler has only global scope, but real compilers handle nested scopes:</p>

                    <pre><code>typedef struct Scope {
    SymbolTable* table;
    struct Scope* parent;  // Outer scope
    int level;             // Nesting depth
} Scope;

// Symbol lookup walks up scope chain:
// 1. Check current scope
// 2. Check parent scope
// 3. Continue until found or reach global</code></pre>

                    <h3>Error Detection Examples</h3>
                    <div class="step">
                        <strong>Undeclared Variable:</strong>
                        <pre><code>int x;
y = 10;  // Error: y not declared</code></pre>
                    </div>

                    <div class="step">
                        <strong>Redeclaration:</strong>
                        <pre><code>int x;
int x;   // Error: x already declared</code></pre>
                    </div>

                    <div class="step">
                        <strong>Use Before Declaration:</strong>
                        <pre><code>x = 10;  // Error: x not declared yet
int x;</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 12: Optimization Theory -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🎯</span>Deep Dive: Optimization Theory</h2>
            <div class="two-column">
                <div>
                    <h3>Data Flow Analysis</h3>
                    <p>Understanding how data flows through the program:</p>

                    <pre><code>x = 5;        // Definition of x
y = x + 3;    // Use of x, definition of y
z = y * 2;    // Use of y, definition of z
print(z);     // Use of z</code></pre>

                    <h3>Reaching Definitions</h3>
                    <p>Which definitions can reach each program point?</p>

                    <pre><code>x = 5;        // D1: x defined here
if (...) {
    x = 10;   // D2: x redefined here
}
y = x + 1;    // Both D1 and D2 can reach here</code></pre>

                    <h3>Live Variable Analysis</h3>
                    <p>Which variables are "live" (will be used again)?</p>

                    <pre><code>x = 5;        // x is live (used below)
y = 10;       // y is live (used below)
z = x + y;    // x,y dead after this, z live
print(z);     // z dead after this</code></pre>
                </div>
                <div>
                    <h3>Optimization Opportunities</h3>

                    <div class="step">
                        <strong>Dead Code Elimination</strong>
                        <pre><code>x = 5;
y = 10;       // y never used - eliminate!
z = x + 3;
print(z);</code></pre>
                    </div>

                    <div class="step">
                        <strong>Constant Propagation</strong>
                        <pre><code>x = 5;        // x is constant
y = x + 3;    // becomes: y = 5 + 3
print(y);     // becomes: print(8)</code></pre>
                    </div>

                    <div class="step">
                        <strong>Common Subexpression Elimination</strong>
                        <pre><code>a = b + c;
d = b + c;    // Same as a - reuse!
// Optimized: d = a;</code></pre>
                    </div>

                    <div class="step">
                        <strong>Loop Optimization (Advanced)</strong>
                        <pre><code>// Loop unrolling, vectorization
for (i = 0; i < 4; i++) {
    a[i] = b[i] + c[i];
}
// Unrolled:
a[0] = b[0] + c[0];
a[1] = b[1] + c[1];
a[2] = b[2] + c[2];
a[3] = b[3] + c[3];</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 13: Code Generation Deep Dive -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">💻</span>Deep Dive: Target Code Generation</h2>
            <div class="two-column">
                <div>
                    <h3>Register Allocation</h3>
                    <p>Real compilers must decide which variables/temporaries go in registers vs memory:</p>

                    <pre><code>// Many variables, few registers
int a, b, c, d, e, f, g, h, i, j;

// MIPS has only:
// $t0-$t7: 8 temporary registers
// $s0-$s7: 8 saved registers

// Must "spill" some variables to memory
// Graph coloring algorithm assigns optimally</code></pre>

                    <h3>Instruction Selection</h3>
                    <p>Multiple ways to generate code for same operation:</p>

                    <pre><code>// x = y + 1;

// Option 1: Load-Add-Store
lw $t0, y_offset($sp)    // Load y
addi $t0, $t0, 1         // Add immediate 1
sw $t0, x_offset($sp)    // Store to x

// Option 2: Direct increment (if x == y)
lw $t0, y_offset($sp)    // Load y
addi $t0, $t0, 1         // Increment
sw $t0, y_offset($sp)    // Store back</code></pre>
                </div>
                <div>
                    <h3>Calling Conventions</h3>
                    <p>How functions call each other (not in our minimal language):</p>

                    <pre><code># MIPS calling convention
# Arguments: $a0-$a3
# Return value: $v0-$v1
# Caller-saved: $t0-$t9
# Callee-saved: $s0-$s7

function_call:
    # Save caller-saved registers
    sw $t0, 0($sp)
    sw $t1, 4($sp)

    # Set up arguments
    li $a0, 42

    # Call function
    jal my_function

    # Use return value
    move $t0, $v0

    # Restore caller-saved registers
    lw $t1, 4($sp)
    lw $t0, 0($sp)</code></pre>

                    <h3>Advanced Topics</h3>
                    <ul>
                        <li><strong>Peephole Optimization</strong>: Improve generated assembly</li>
                        <li><strong>Pipeline Scheduling</strong>: Arrange instructions for CPU pipeline</li>
                        <li><strong>Cache Optimization</strong>: Arrange data for cache efficiency</li>
                        <li><strong>SIMD Instructions</strong>: Vector operations for parallelism</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 14: Compiler Construction Best Practices -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🏗️</span>Compiler Construction Best Practices</h2>
            <div class="two-column">
                <div>
                    <h3>Error Recovery</h3>
                    <p>Our compiler stops on first error, but production compilers continue:</p>

                    <pre><code>int x;
int y;
x = 10;
y = z + 5;    // Error: z undeclared
print(y);     // Continue parsing anyway</code></pre>

                    <h3>Error Messages</h3>
                    <div class="step">
                        <strong>Bad:</strong>
                        <pre><code>"Syntax error on line 4"</code></pre>
                    </div>

                    <div class="step">
                        <strong>Good:</strong>
                        <pre><code>"Error on line 4: Variable 'z' used but not declared
Suggestion: Did you mean variable 'x'?"</code></pre>
                    </div>

                    <h3>Performance Considerations</h3>
                    <ul>
                        <li><strong>Memory Management</strong>: Avoid leaks in AST construction</li>
                        <li><strong>Algorithm Complexity</strong>: Use efficient data structures</li>
                        <li><strong>Compilation Speed</strong>: Balance optimization vs compile time</li>
                    </ul>
                </div>
                <div>
                    <h3>Testing Strategy</h3>

                    <div class="step">
                        <strong>1. Unit Tests</strong>
                        <p>Test individual phases</p>
                        <pre><code>test_lexer_tokens()
test_parser_grammar()
test_symbol_table()
test_tac_generation()
test_optimization()
test_code_generation()</code></pre>
                    </div>

                    <div class="step">
                        <strong>2. Integration Tests</strong>
                        <p>Test full compilation pipeline</p>
                        <pre><code>test_simple_program()
test_complex_expressions()
test_error_handling()</code></pre>
                    </div>

                    <div class="step">
                        <strong>3. Regression Tests</strong>
                        <p>Ensure fixes don't break existing code</p>
                    </div>

                    <div class="step">
                        <strong>4. Stress Tests</strong>
                        <p>Large programs, edge cases</p>
                        <pre><code>test_1000_variables()
test_deeply_nested_expressions()
test_boundary_conditions()</code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 15: Research Connections -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🔬</span>Research Connections</h2>
            <div class="two-column">
                <div>
                    <h3>Advanced Optimization</h3>
                    <ul>
                        <li><strong>Loop Optimization</strong>: Unrolling, vectorization, parallelization</li>
                        <li><strong>Interprocedural Analysis</strong>: Whole-program optimization</li>
                        <li><strong>Profile-Guided Optimization</strong>: Use runtime data to guide optimization</li>
                        <li><strong>Auto-Vectorization</strong>: Automatic SIMD code generation</li>
                        <li><strong>Polyhedral Optimization</strong>: Mathematical loop transformations</li>
                    </ul>

                    <h3>Modern Compiler Techniques</h3>
                    <ul>
                        <li><strong>Just-In-Time Compilation</strong>: Runtime compilation (Java HotSpot, V8)</li>
                        <li><strong>Ahead-of-Time Compilation</strong>: Full compilation before deployment</li>
                        <li><strong>Cross-Compilation</strong>: Target different architectures</li>
                        <li><strong>Adaptive Optimization</strong>: Optimize based on runtime behavior</li>
                    </ul>
                </div>
                <div>
                    <h3>Domain-Specific Languages</h3>
                    <div class="step">
                        <strong>SQL Compilers</strong>
                        <p>Optimize database queries</p>
                        <pre><code>SELECT * FROM users WHERE age > 25
↓
Index scan on age_index
Filter predicate: age > 25
Hash join with main table</code></pre>
                    </div>

                    <div class="step">
                        <strong>Shader Compilers</strong>
                        <p>GPU programming languages (GLSL, HLSL)</p>
                        <pre><code>// Vertex shader optimization
// Parallel execution on thousands of cores</code></pre>
                    </div>

                    <div class="step">
                        <strong>Configuration Languages</strong>
                        <p>Terraform, Kubernetes YAML</p>
                        <pre><code>resource "aws_instance" "web" {
  ami = "ami-12345"
}
↓
AWS API calls to create infrastructure</code></pre>
                    </div>

                    <h3>Future Directions</h3>
                    <ul>
                        <li><strong>Machine Learning in Compilers</strong>: ML-guided optimization</li>
                        <li><strong>Quantum Computing</strong>: Quantum circuit compilation</li>
                        <li><strong>Neuromorphic Computing</strong>: Brain-inspired architectures</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 16: Building & Running -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🚀</span>Build & Run the Compiler</h2>
            <div class="two-column">
                <div>
                    <h3>Prerequisites</h3>
                    <ul>
                        <li><code>flex</code> (lexical analyzer generator)</li>
                        <li><code>bison</code> (parser generator)</li>
                        <li><code>gcc</code> (C compiler)</li>
                        <li>MIPS simulator (MARS, SPIM, QtSPIM)</li>
                    </ul>

                    <h3>Compilation</h3>
                    <pre><code># Build the compiler
make

# Compile a source file
./minicompiler test.c output.s

# Clean build files
make clean</code></pre>

                    <h3>Example Programs</h3>
                    <div class="step">
                        <strong>Simple Addition:</strong>
                        <pre><code>int a; int b; int sum;
a = 5; b = 7;
sum = a + b;
print(sum);    // Output: 12</code></pre>
                    </div>
                </div>
                <div>
                    <h3>Example Session</h3>
                    <pre><code>$ ./minicompiler test.c output.s

╔══════════════════════════════════════╗
║    MINIMAL C COMPILER - EDUCATIONAL  ║
╚══════════════════════════════════════╝

┌────────────────────────────────────┐
│ PHASE 1: LEXICAL & SYNTAX ANALYSIS │
├────────────────────────────────────┤
│ • Reading source file: test.c
│ • Tokenizing input (scanner.l)
│ • Parsing grammar rules (parser.y)
│ • Building Abstract Syntax Tree
└────────────────────────────────────┘
✓ Parse successful!

┌────────────────────────────────────┐
│ PHASE 2: SYMBOL TABLE TRACING     │
├────────────────────────────────────┤
│ SYMBOL TABLE: Initialized
│ SYMBOL TABLE: Added variable 'x'
│ SYMBOL TABLE: Added variable 'y'
└────────────────────────────────────┘

[... TAC generation, optimization,
     MIPS generation ...]

✓ MIPS assembly generated to: output.s</code></pre>

                    <h3>Running the Output</h3>
                    <p>Load <code>output.s</code> in a MIPS simulator like MARS or SPIM to execute the compiled program!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 17: Complete Example Walkthrough -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🔍</span>Complete Example Walkthrough</h2>
            <div style="font-size: 0.9em;">
                <h3 class="center-text">Source Code → Final Assembly</h3>

                <div class="step">
                    <strong>1. Source Code:</strong>
                    <pre><code>int x; int y; int result;
x = 10; y = 20;
result = x + y;
print(result);</code></pre>
                </div>

                <div class="step">
                    <strong>2. Tokens (Lexical Analysis):</strong>
                    <pre><code>INT ID SEMICOLON INT ID SEMICOLON INT ID SEMICOLON
ID ASSIGN NUM SEMICOLON ID ASSIGN NUM SEMICOLON
ID ASSIGN ID PLUS ID SEMICOLON PRINT LPAREN ID RPAREN SEMICOLON</code></pre>
                </div>

                <div class="step">
                    <strong>3. AST (Syntax Analysis):</strong>
                    <pre><code>STMT_LIST
├── DECL(x)
├── DECL(y)
├── DECL(result)
├── ASSIGN(x, NUM(10))
├── ASSIGN(y, NUM(20))
├── ASSIGN(result, BINOP(+, VAR(x), VAR(y)))
└── PRINT(VAR(result))</code></pre>
                </div>

                <div class="step">
                    <strong>4. Symbol Table Evolution:</strong>
                    <pre><code>After declarations: x→offset:0, y→offset:4, result→offset:8</code></pre>
                </div>

                <div class="step">
                    <strong>5. TAC (Intermediate Code):</strong>
                    <pre><code>1: DECL x     2: DECL y     3: DECL result
4: x = 10     5: y = 20     6: t0 = x + y
7: result = t0     8: PRINT result</code></pre>
                </div>

                <div class="step">
                    <strong>6. Optimized TAC:</strong>
                    <pre><code>1: DECL x     2: DECL y     3: DECL result
4: x = 10     5: y = 20     6: result = 30
7: PRINT 30</code></pre>
                </div>

                <div class="step">
                    <strong>7. Final MIPS Assembly:</strong>
                    <pre><code>.data
.text
.globl main
main:
    addi $sp, $sp, -400
    li $t0, 10; sw $t0, 0($sp)    # x = 10
    li $t1, 20; sw $t1, 4($sp)    # y = 20
    lw $t0, 0($sp); lw $t1, 4($sp); add $t0, $t0, $t1; sw $t0, 8($sp)  # result = x + y
    lw $t0, 8($sp); move $a0, $t0; li $v0, 1; syscall  # print(result)
    addi $sp, $sp, 400; li $v0, 10; syscall            # exit</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 18: Learning Objectives -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🎯</span>Learning Objectives</h2>
            <div class="two-column">
                <div>
                    <h3>Core Concepts</h3>
                    <ol>
                        <li><strong>Lexical Analysis</strong>: Text → tokens using finite automata</li>
                        <li><strong>Parsing</strong>: Tokens → syntax trees using context-free grammars</li>
                        <li><strong>Semantic Analysis</strong>: Meaning verification through symbol tables</li>
                        <li><strong>Intermediate Representations</strong>: Platform-independent code design</li>
                        <li><strong>Optimization</strong>: Data flow analysis and code transformation</li>
                    </ol>

                    <h3>Implementation Skills</h3>
                    <ol start="6">
                        <li><strong>Code Generation</strong>: Instruction selection and register allocation</li>
                        <li><strong>Memory Management</strong>: Stack layout and variable storage</li>
                        <li><strong>Compilation Pipeline</strong>: How phases connect and information flows</li>
                    </ol>
                </div>
                <div>
                    <h3>Software Engineering</h3>
                    <ol start="9">
                        <li><strong>Error Handling</strong>: Robust compiler design</li>
                        <li><strong>Testing</strong>: Unit, integration, and regression testing</li>
                        <li><strong>Modularity</strong>: Clean separation of compiler phases</li>
                    </ol>

                    <h3>Systems Understanding</h3>
                    <ol start="12">
                        <li><strong>Computer Architecture</strong>: How code becomes machine instructions</li>
                        <li><strong>Runtime Systems</strong>: Stack management, calling conventions</li>
                        <li><strong>Performance</strong>: Optimization trade-offs and analysis</li>
                    </ol>

                    <div class="highlight">
                        <h3>🎓 Course Outcomes</h3>
                        <p>Students will be able to:</p>
                        <ul>
                            <li>Design and implement compiler phases</li>
                            <li>Analyze programming language constructs</li>
                            <li>Optimize code for performance</li>
                            <li>Debug compilation issues systematically</li>
                            <li>Understand modern compiler research</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 19: Next Steps & Extensions -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🚀</span>Next Steps & Extensions</h2>
            <div class="two-column">
                <div>
                    <h3>Language Extensions</h3>
                    <ul>
                        <li><strong>Control Flow</strong>: if-else statements, while loops</li>
                        <li><strong>Functions</strong>: Function declarations and calls</li>
                        <li><strong>Arrays</strong>: Array declarations and indexing</li>
                        <li><strong>Data Types</strong>: float, char, boolean types</li>
                        <li><strong>Strings</strong>: String literals and operations</li>
                        <li><strong>Pointers</strong>: Address-of, dereference operators</li>
                    </ul>

                    <h3>Optimization Extensions</h3>
                    <ul>
                        <li><strong>Dead Code Elimination</strong>: Remove unused code</li>
                        <li><strong>Loop Optimizations</strong>: Unrolling, invariant motion</li>
                        <li><strong>Register Allocation</strong>: Graph coloring algorithm</li>
                        <li><strong>Peephole Optimization</strong>: Local assembly improvements</li>
                        <li><strong>Inlining</strong>: Replace function calls with body</li>
                    </ul>

                    <h3>Target Extensions</h3>
                    <ul>
                        <li><strong>x86-64 Backend</strong>: Generate Intel assembly</li>
                        <li><strong>ARM Backend</strong>: Target mobile/embedded devices</li>
                        <li><strong>LLVM IR</strong>: Generate LLVM intermediate representation</li>
                        <li><strong>WebAssembly</strong>: Compile to WASM for browsers</li>
                    </ul>
                </div>
                <div>
                    <h3>Advanced Features</h3>
                    <ul>
                        <li><strong>Error Recovery</strong>: Continue after syntax errors</li>
                        <li><strong>Debugging Info</strong>: Generate debug symbols</li>
                        <li><strong>Preprocessor</strong>: Macro expansion, includes</li>
                        <li><strong>Linker Support</strong>: Multiple object files</li>
                        <li><strong>Standard Library</strong>: Built-in functions</li>
                    </ul>

                    <h3>Research Projects</h3>
                    <div class="step">
                        <strong>Machine Learning Integration</strong>
                        <p>Use ML to guide optimization decisions</p>
                    </div>

                    <div class="step">
                        <strong>Domain-Specific Languages</strong>
                        <p>Create specialized compilers for specific domains</p>
                    </div>

                    <div class="step">
                        <strong>Parallel Compilation</strong>
                        <p>Speed up compilation using multiple cores</p>
                    </div>

                    <div class="step">
                        <strong>Interactive Development</strong>
                        <p>Language servers, real-time error checking</p>
                    </div>

                    <div class="highlight">
                        <h3>🎯 Your Challenge</h3>
                        <p>Pick one extension and implement it! Start with control flow (if-else) - it touches every compiler phase and teaches fundamental concepts.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Slide 20: Conclusion -->
    <div class="slide-container">
        <div class="slide fade-in">
            <h2><span class="emoji">🎓</span>Conclusion</h2>
            <div class="center-text">
                <h3>What You've Learned</h3>
                <p style="font-size: 1.3em; margin: 30px 0;">
                    You've explored a complete compiler implementation from source code to machine assembly,
                    understanding each phase and how they work together.
                </p>

                <div class="pipeline" style="margin: 40px 0;">
                    <div class="pipeline-box" style="background: rgba(255, 235, 59, 0.3);">
                        <strong>Real Compiler Knowledge</strong><br>
                        Not just theory - working code you can run and modify
                    </div>
                    <div class="pipeline-arrow">↓</div>
                    <div class="pipeline-box" style="background: rgba(129, 199, 132, 0.3);">
                        <strong>Deep Understanding</strong><br>
                        From high-level code to assembly instructions
                    </div>
                    <div class="pipeline-arrow">↓</div>
                    <div class="pipeline-box" style="background: rgba(100, 181, 246, 0.3);">
                        <strong>Practical Skills</strong><br>
                        Ready to tackle real compiler projects
                    </div>
                </div>

                <h3>The Journey Continues</h3>
                <div class="two-column" style="text-align: left; margin-top: 30px;">
                    <div>
                        <h4>🔬 Research Opportunities</h4>
                        <ul>
                            <li>Machine learning in compilation</li>
                            <li>Quantum computing languages</li>
                            <li>Domain-specific optimizations</li>
                            <li>Parallel and distributed compilation</li>
                        </ul>
                    </div>
                    <div>
                        <h4>🏭 Industry Applications</h4>
                        <ul>
                            <li>Programming language design</li>
                            <li>Performance optimization</li>
                            <li>Development tools creation</li>
                            <li>Systems programming</li>
                        </ul>
                    </div>
                </div>

                <div class="highlight" style="margin-top: 40px;">
                    <h3>🌟 Final Thought</h3>
                    <p style="font-size: 1.4em;">
                        "Understanding compilers gives you a superpower: the ability to bridge the gap
                        between human thought and machine execution."
                    </p>
                </div>

                <p style="font-size: 1.2em; margin-top: 30px; color: #ffeb3b;">
                    <strong>Thank you for exploring compiler design with us!</strong>
                </p>
            </div>
        </div>
    </div>

    <div class="navigation">
        <button class="nav-btn" id="prev-btn" onclick="previousSlide()">← Previous</button>
        <button class="nav-btn" id="home-btn" onclick="goToSlide(0)">Home</button>
        <button class="nav-btn" id="next-btn" onclick="nextSlide()">Next →</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide-container');
        const totalSlides = slides.length;

        document.getElementById('total-slides').textContent = totalSlides;

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = n;

            if (currentSlide >= totalSlides) currentSlide = 0;
            if (currentSlide < 0) currentSlide = totalSlides - 1;

            slides[currentSlide].classList.add('active');
            slides[currentSlide].classList.add('fade-in');

            document.getElementById('current-slide').textContent = currentSlide + 1;

            // Update navigation buttons
            document.getElementById('prev-btn').disabled = currentSlide === 0;
            document.getElementById('next-btn').disabled = currentSlide === totalSlides - 1;

            // Remove fade-in class after animation
            setTimeout(() => {
                slides[currentSlide].classList.remove('fade-in');
            }, 800);
        }

        function nextSlide() {
            if (currentSlide < totalSlides - 1) {
                showSlide(currentSlide + 1);
            }
        }

        function previousSlide() {
            if (currentSlide > 0) {
                showSlide(currentSlide - 1);
            }
        }

        function goToSlide(n) {
            showSlide(n);
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                previousSlide();
            } else if (e.key === 'Home') {
                e.preventDefault();
                goToSlide(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                goToSlide(totalSlides - 1);
            }
        });

        // Initialize
        showSlide(0);

        // Prevent context menu for cleaner presentation
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>